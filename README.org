#+STARTIP: overview
* What is this?
This file is an org mode file that emacs can use to generate configuration.

Almost all of the code blocks you see below are placed into init.el. This has two benefits: I don't have to comment this code with semicolons, and I can easily navigate to what code I'd like to edit or add. Here's a picture of my config as I see it:

[[http://i.imgur.com/yQPukq6.png]]

I won't be going over what each package does, (the README files do a better job than I could do), but I will be going over config details.

Initially I used [[https://github.com/quelpa/quelpa][quelpa]] to manage my configuration, in an attempt to have completely reproducible config. I'm using [[https://github.com/raxod502/straight.el][straight.el]] here to make it easier to validate patches and contribute them upstream and also to make sure I can rollback just like I can on NixOS.
* Config
** Straight bootstrap
Straight downloads a file. Wondering why bootstrap-version is defined in this block but never used. Even though emacs has dynamic binding, I'm not setting the version globally...
#+BEGIN_SRC emacs-lisp :tangle init.el
(let ((bootstrap-file (concat user-emacs-directory "straight/bootstrap.el"))
      (bootstrap-version 2))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC 

Use ssh as default for authentication and for delivery.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq straight-vc-git-default-protocol 'ssh)
#+END_SRC

** Use-package
Use package is a way to tidy up config and a convenient way to lazy load packages (that is, defer loading so that emacs doesn't load everything on startup).
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package 'use-package)

  ;; bind-key is provided with use-package, diminish I only use once or twice
  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
#+END_SRC

** Disabling 'helpful' visual goodies
The only useful thing I lose here is the menubar, but typing <F10> gives you one at your cursor. And now I get all this real estate (it's free!)
#+BEGIN_SRC emacs-lisp :tangle init.el
;; can be recovered with <F10>
(tool-bar-mode -1)

;; not needed, just look at the mode line for gauging where you are in the buffer
(scroll-bar-mode -1)

;; wait which one is which
(menu-bar-mode -1)

;; you can set this to some arbitrary number so that it will blink for that number of times. I don't like blinking.
(blink-cursor-mode 0)

;; pretty quotes can't be jumped to easily.
(setq text-quoting-style 'grave)
#+END_SRC

** Enabling 'helpful' visual goodies
Might be considered a hindrance, but I rarely need more than 80 columns while programming and would rather not have to deal with horizontal scrolling. These two settings are neat for prose, and org mode.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; enabling visual line mode
(visual-line-mode 1)

(toggle-word-wrap)
#+END_SRC

I don't know how I feel using hl-line-mode on EVERY buffer. Instead, let's just add the ones that make sense.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defvar my-hl-line-mode-hook-list
  `(prog-mode-hook
    circe-mode-hook))

(dolist (this-mode-hook my-hl-line-mode-hook-list)
  (add-hook this-mode-hook `hl-line-mode))
#+END_SRC

** Making emacs snappier
any dialog that asks for confirmation requires that you type in the full yes or no (and ignores whatever is after it, but does not accept y/n). Setting it to y-or-n-p allows you to do this. And you don't have to hit RET.
#+BEGIN_SRC emacs-lisp :tangle init.el
(fset `yes-or-no-p `y-or-n-p)
#+END_SRC

Echoing keystrokes allows you to see exactly what you've typed almost immediately. Doesn't sound useful, but it is appreciated often.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq echo-keystrokes 0.1)
#+END_SRC

Tell emacs to paste at point, not on location of click. Now if C-y doesn't work, I can use my mouse without caring about precision.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq mouse-yank-at-point t)
#+END_SRC

These options were brought to me, again, by [[https://github.com/wasamasa/dotemacs/blob/master/init.org][wasamasa's config]

Don't ask me to follow symlinks, just warn me and do it always.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq vc-follow-symlinks nil)
#+END_SRC

** Removing disabled function
Emacs should let me be as stupid as I want.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq disabled-command-function nil)
#+END_SRC

** lsp-mode
The language server protocol is neat! I'd like to be able to use emacs to edit java, kotlin code with little fuss. This requires jump to definition, find usages, _maybe_ incremental compilation. 

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'lsp-mode)
#+END_SRC

** Buttercup
A BDD testing framework for emacs lisp. Other powerpuff girls not included.

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'buttercup)
#+END_SRC

** evil-mode
My relationship with evil is a healthy one. I can navigate fine without the keybinds but a lot of the constructs are already ingrained, and bound for me conveniently. Take #. The emacs alternative is word-search-backward, but I would have to bind it myself. I'd also have to write advice to provide the default word at point for equivalent functionality. Why do I have to ditch #? We have a good thing going. Let's keep it that way.

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'evil)  ;; no plans to contrib upstream for now.
(use-package evil
#+END_SRC

evil likes to override my C-z key with evil-toggle-state. But if I set this before I load evil, it no longer gets overridden. 
#+BEGIN_SRC emacs-lisp :tangle init.el
 :init
  (setq evil-toggle-key "C-`")
#+END_SRC

evil's undo is a little strong, especially since I'm staying in insert ("emacs", later explained) mode more often.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq evil-want-fine-undo t)
#+END_SRC

Turn evil mode on globally
#+BEGIN_SRC emacs-lisp :tangle init.el
  :config
  (evil-mode t)
#+END_SRC

the below is used to have emacs be the default state, but allow me to drop in (pop up?) to evil if need be.
more config is available in the URL contained within the progn

there are significantly less context switches now. when I am in a new buffer, I know I am in emacs state, and can begin typing immediately. If I want to do anything evil, just hit esc to elevate to normal state.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (progn
    (defalias 'evil-insert-state 'evil-emacs-state) ; http://stackoverflow.com/a/27794225/2932728
    (setq evil-default-state 'emacs)
    ;; https://bitbucket.org/bastibe/.emacs.d/src/12d08ec90a6445787b028fa8640844a67182e96d/init.el?at=master&fileviewer=file-view-default
    (define-key evil-emacs-state-map [escape] 'evil-normal-state)
    )
  ;; I didn't put the above define-key into the bind just because it makes more sense here. If I encounter a remapping of esc, I'd probably move it into bind*

  ;; IDK about motion state, it blocks useful keys, like ? or h. (which I get to by typing "\" in normal mode)
#+END_SRC

a quick way to differentiate which state I'm in without looking at the mode line, may change this later.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq evil-emacs-state-cursor `(hbar . 2))
#+END_SRC

I highly value colors.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq evil-lookup-func (lambda () (call-interactively 'man)))
#+END_SRC

inserts highly visible characters at marks. they go away upon entering visual mode or 'insert' mode.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package 'evil-visual-mark-mode)
  (use-package evil-visual-mark-mode
    :config
    (evil-visual-mark-mode))
#+END_SRC

Once you start binding keys, use-package will lazy-load the packages, that is, wait until you hit a key that is in the bind before loading.
While a useful feature, in this case I want evil-mode active on start.
#+BEGIN_SRC emacs-lisp :tangle init.el
  :demand t
#+END_SRC


Even though I use emacs-state as my insert state, I still want certain things to be available all the time, no matter what state I'm in.

#+BEGIN_SRC emacs-lisp :tangle init.el
    :bind* (:map evil-emacs-state-map
                 ("C-r" . evil-paste-from-register)

                 :map evil-normal-state-map
                 ("C-f" . evil-scroll-down)
                 ("C-b" . evil-scroll-up)
                 ("j" . evil-next-visual-line)
                 ("k" . evil-previous-visual-line)
                 ("'" . evil-goto-mark)
                 ("C-e" . end-of-line)
                 ("C-y" . yank)
                 ("C-d" . evil-scroll-down)
                 ("C-t" . ace-window)

                 :map evil-motion-state-map
                 ("C-f" . evil-scroll-down)
                 ("C-b" . evil-scroll-up))
  ) ;; closes use-package evil block
#+END_SRC

** general

[[https://github.com/noctuid/general.el][General]] is a package that aims to simplify and unify keybinding. Problems I have with letting bind-key handle it is that it's difficult to tailor. An example: in dired mode, I like having the ability to move by jk or having visual block/line selection. At the same time, I want dired mode bindings available. So I bind "i" to evil-insert-state.  However I have no idea how to do it with bind-key. Further, this allows me to get rid of evil-leader. The less packages I depend on for my output, the better.

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'general)
  (use-package general
    ;; maybe in the future make this config evil agnostic?
    :if (featurep 'evil)
    :config

    ;; leader key binds
    (setq general-default-keymaps '(evil-normal-state-map
                                    evil-visual-state-map))

    (setq general-default-prefix "SPC")
    (general-define-key
                        
     "g" 'keyboard-quit
     "C-g" 'keyboard-quit
     "SPC" 'ace-window

     "w" 'save-buffer
     "v" 'visual-line-mode
     "t" 'toggle-word-wrap
     "s" 'magit-status
     
     "a" 'org-agenda-list
     
     "m" 'fill-region

     ;; in the case that we don't have projectile, fall back to
     ;; vanilla find-file
     "f" (if (featurep 'projectile)
             'projectile-find-file
           'find-file)
     "p" 'my-find-projects
     "o" 'my-find-org-files

     "r" 'org-capture

     "i" 'imenu

     ) ;; closes general-define-key block
    
  ) ;; closes use-package general block
#+END_SRC

** dired
I didn't bother playing around with dired but the amount of built in functionality is kind of insane. Edit all files in directories that you can just open in the same buffer with the same regex kind of insane.

Just.. don't play around with my keymaps.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package dired
    :config
    (define-key dired-mode-map (kbd "SPC") nil)
    (define-key dired-mode-map (kbd "M-s") nil)
    
    ;; remove dired-mode-map definition
    (define-key dired-mode-map (kbd "i") nil)
    
    (general-define-key :prefix nil
                        :keymaps 'dired-mode-map
                        :states '(normal)
                        "i" 'evil-insert-state)
                        
    (general-define-key :prefix nil
                        :keymaps 'dired-mode-map
                        :states '(emacs)
                        "i" 'dired-maybe-insert-subdir)

  )
#+END_SRC

** tramp

scp is the default. I'm... not sure why I set this initially.
#+BEGIN_SRC emacs-lisp :tangle init.el
(setq tramp-default-method "ssh")
#+END_SRC

** swiper/ivy
man do I love this package. Lightweight, pretty, and FAST. Enabling ivy mode globally gives most aspects of the minibuffer fuzzy typeahead (like ido-mode) but it further allows you to keep your search session if needed (especially useful when looking in help variables). Swiper is used to search buffers, and uses ivy as a backend. It is possible to use helm as a backend instead.
#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'ivy)
  (use-package ivy
    :demand t
    :diminish ivy-mode
    :config
    (setq ivy-ignore-buffers `("\\` "))
    
    ;; i like completion in the minibuffer, completion in region is obnoxious when you have hl-line-mode active. This must be set before ivy-mode is called.
    (setcdr (assoc 'ivy-completion-in-region ivy-display-functions-alist) nil)

    (ivy-mode t))

  (use-package swiper
    :config

    ;; almost required, I use search a lot for navigation, especially in
    ;;   this growing init file. Note that if multiple candidates are in a
    ;;   view moving between them does not recenter the buffer.
    (setq swiper-action-recenter t)

    ;; shadows isearch
    :bind* (("C-s" . swiper))
    )

#+END_SRC

Counsel-yank-pop is much easier to use than kill ring drive bys.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package 'counsel)
  (use-package counsel
    :bind* (("M-x" . counsel-M-x)
            ("C-c a" . counsel-ag))
  )
#+END_SRC

** ace-window
C-x o is way too much to switch between windows (which is an operation I find myself doing near constantly). I used to use something like [[http://oremacs.com/2015/02/14/semi-xmodmap/][semimap]] for my keyboard configuration, but have fallen out of doing that (hence why you'll find unicode binds randomly dispersed).

#+BEGIN_SRC emacs-lisp :tangle init.el

(straight-use-package 'ace-window)
  (use-package ace-window
    :bind*
    (("C-t" . ace-window))
    :config
    (setq aw-scope 'frame)
    )
#+END_SRC

** magit

Magit spoils me.
#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'magit)
(use-package magit)
#+END_SRC

** org mode
Ah, org mode. Lovingly described as the crack of emacs.

#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package org
  :init
  (setq org-directory "~/Documents/org/")

  (setq org-default-notes-file (concat org-directory "notes.org"))
#+END_SRC

org-capture is fantastic. if you're anything like me you have ideas that come and go like the wind. this allows you to easily capture those ideas without worrying about where to save them, whether or not context is necessary, the directory structure. It's a massively beefed up remember buffer. If you want something that just works without any previous configuration, then try M-x remember, the file will be saved in your .emacs.d directory, and it's called notes.

when you invoke org-capture interactively, a buffer pops up that waits for you to enter in a key. this key takes you to a special buffer that you can format beforehand with a template variable (customized below). this then saves it to the file you specify.

I do recommend saving all of these to a common place, that way you can define a key to go to where all of these are saved and look at them fully

a quick primer: this is a listing, where each element is itself a list that follows this format:
#+BEGIN_SRC emacs-lisp
  ("a" ; key to be pressed, does not have to have to be just one key
       ; but there are some special rules if you want to use two (or rms forbid, 3)

   "astrology" ; whatever you want the capture template to be called in the popup buffer. keep it short, but I don't think there's a low limit on these.

   plain ; the type of entry you want, unquoted. check out the link below, it offers a concise listing of these if you need more.

   (file ; this argument is a list, itself. get used to lists within lists within lists. the one I use the most is file+datetree, which files all my notes in a clear ... uh... datetree format. for more details, look below.

    "baz.org")) ; this will be concatenated (probably not if you use an absolute path, check out expand-file-name)
#+END_SRC

and that's it! for more info, check out [[http://orgmode.org/manual/Template-elements.html#Template-elements][the org mode manual for templates!]]

#+BEGIN_SRC emacs-lisp :tangle init.el
   (setq my-org-capture-directory "~/Documents/org/capture/")
   
   (setq org-capture-templates
         '(("t" "Todo" entry (file+headline "~/Documents/org/gtd-capture.org" "Tasks")
            "* TODO %?\n  %i\n  %a")
           ("j" "Journal" entry (file+datetree "~/Documents/org/journal.org")
            "* %?\nEntered on %U\n  %i\n  %a")
           ("e" "Emacs" entry (file+datetree "~/Documents/org/emacs.org")
            "* %?\nEntered on %U\n  %i\n  %a")
           ("k" "KOL" entry (file+datetree "~/Documents/org/kol.org")
            "* %?\nEntered on %U\n %a")
           ("a" "ascension" entry (file+datetree "~/Documents/org/kol-ascension.org")
            "* %?\nEntered on %U\n %a")
           ("r" "track" entry (file+datetree "~/Documents/org/track.org")
            "* %?\nEntered on %U\n")
           ("d" "dose" entry (file+datetree "~/Documents/org/dose.org")
            "* %?\nEntered on %U\n")
           ("g" "grievances" entry (file+datetree "~/Documents/org/grievances.org")
            "* %?\nEntered on %U\n %i")
           ("p" "programming" entry (file+datetree "~/Documents/org/programming.org")
            "* %?\nEntered on %U\n  %i")
           ("l" "laptop" entry (file+datetree "~/Documents/org/laptop.org")
            "* %?\nEntered on %U\n %i")
           ("m" "music" entry (file+datetree "~/Documents/org/music.org")
            "* %?\nEntered on %U\n %i")
           ("u" "uncategorized-mess" entry (file+datetree "~/Documents/org/u-mess.org")
            "* %?\nEntered on %U\n")
           ("h" "recurse" entry (file+datetree "~/Documents/org/recurse.org")
            "* %?\nEntered on %U\n")
           ("c" "coffee" entry (file+datetree "~/Documents/org/coffee.org")
            "* %?\nEntered on %U\n")
           )
         )
#+END_SRC

Here we hold most of our gtd configuration, following [[http://orgmode.org/worg/org-tutorials/orgtutorial_dto.html][this post]]. This means org-agenda... other stuff.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq org-agenda-files (list "~/Documents/org/gtd-capture.org"))
#+END_SRC

We're still in the use package declaration. Close it off, and throw in an easy bind in case we can't get to it any other way.
#+BEGIN_SRC emacs-lisp :tangle init.el
   :bind*
   (("<f6>" . org-capture))
   )
#+END_SRC

** term
I'm not exactly happy with term. There's a bunch of workarounds and keys get rebound and still I encounter usability issues. But it works enough, and I have good clipboard (and visual selection) interaction. So it stays. Maybe someone with knowledge of how to do things the right way will get a real terminal working by embedding or linking to the binary.

I use term instead of ansi-term (tried it in a previous iteration) because it's much clearer to configure. I still have no idea how to make ansi-term not insert line breaks.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package term 
    :config
    ;; most of this config is from:
    ;; http://echosa.github.io/blog/2012/06/06/improving-ansi-term/

    ;; don't modify my output please (note this breaks when displaying
    ;; multiline commands at the bottom of the buffer)
    (setq term-suppress-hard-newline t)

    ;; kill the buffer after finishing.
    (defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
      (if (memq (process-status proc) '(signal exit))
          (let ((buffer (process-buffer proc)))
            ad-do-it
            (kill-buffer buffer))
        ad-do-it))
    (ad-activate 'term-sentinel)

    ;; why is this not the default? 
    (defun my-term-use-utf8 ()
      (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
    (add-hook 'term-exec-hook 'my-term-use-utf8)


    ;; eh.. this makes me sad. All I wanted was C-x.
    ;; (defun my-ad-term-line-mode (_arg)
    ;;   (term-line-mode))
    ;; (advice-add 'term :after #'my-ad-term-line-mode)
    ;; (advice-add 'ansi-term :after #'my-ad-term-line-mode)
    
      


    ;; 2048 lines of output is way too restrictive.
    (setq term-buffer-maximum-size 8192)
    :bind*
    (("C-z" . term)
     :map term-raw-map
     ("C-y" . term-paste))
  )
#+END_SRC
** which-key
which-key is fantastic. It provides a visual reminder for any keymap. It even has a dialog for showing the top level binds (I bind it here to C-h SPC)

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'which-key)
(use-package which-key
  :demand t
  :diminish which-key-mode
  :bind* 
  (("C-h SPC" . which-key-show-top-level))
  :config
  (which-key-mode))
#+END_SRC

** buffer filtering 
Wrought from Mount Olympus
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package ibuffer
  :config
  (global-set-key (kbd "C-x C-b") 'ibuffer))

#+END_SRC

** elpy
It was a little difficult figuring out how to change tests programmatically, so if you want to use something else, first M-x elpy-set-test-runner , and then query elpy-test-runner. For py.test, I had to use the symbol elpy-test-pytest-runner.

#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'elpy)
(use-package elpy
  :config

  ;; py.test is actively developed. 
  (elpy-set-test-runner `elpy-test-pytest-runner)

  ;; silences completion warning. found on ob-python's issue pages, strangely enough.
  (setq python-shell-completion-native-enable nil) 

  ;; preference
  (setq elpy-rpc-backend "jedi")
  (setq elpy-rpc-python-command "python3")
  (setq python-shell-interpreter "python3")
  
  ;; start
  (elpy-enable))
#+END_SRC

** kotlin
#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'kotlin-mode)
#+END_SRC

Previously I had an LSP block here, but it just wasn't good enough, for two reasons:
The first was starting it was hacky AF. There are alternatives of using something like idea-lsp or intellij-lsp, but I'm going to confine that hackery to my work machine.

The second meant I had to have the lsp server installed on each machine. Now I only have two, but this kinda tramples over the nice feature of emacs that I can have the exact same dev environment with just a git clone, where everything's self contained.

** rust
Oh, you knew it was coming.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package 'rust-mode)
  (straight-use-package 'cargo)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
  (use-package cargo
    :config
    (setq cargo-process--custom-path-to-bin "./cargo")
    ;; likely no need to create custom rustc paths, just use the
    ;; global one
    (setq cargo-process--rustc-cmd "\"$(nix-build '<nixpkgs>' --no-build-output -A rustc)/bin/rustc\"")
  )


  ;; somewhere I read that using add-to-list is not enough, even though it mutates the list..
  ;; I'll leave out the setq at first and see if emacs cooperates 
  (add-to-list 'auto-mode-alist '("\\.rs" . rust-mode))
#+END_SRC

** markdown-mode
For authoring pelican posts, and for README's that aren't in org.

It just recently had its 10th birthday!
#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'markdown-mode)
#+END_SRC

** indium
casual inspection of DOMS and JS objects on the fly

probably going to hit this next at RC. 

#+BEGIN_SRC emacs-lisp :tangle init.el
  (use-package indium
    :disabled t
    :config
    ;; delete all jsm modes..
    ;; I wonder what disqualifies a mode from being applicable to the environment.
    ;; (setq auto-mode-alist (assq-delete-all "\\.jsm?\\'" auto-mode-alist))
    ;; make js2-mode (javascript-IDE) the default
    ;; (setq auto-mode-alist (add-to-list '("\\.jsm?\\'" . js2-mode) auto-mode-alist))
    (add-hook 'js2-mode-hook 'indium-interaction-mode))
  (setq indium-chrome-executable "chromium-browser")
#+END_SRC

** circe

[[https://github.com/jorgenschaefer/circe][Circe]] is described as an IRC client that is an intermediary between erc and rcirc. It features pretty good default options (with one exception that's really not all that important), and default network configuration out of the box. It's written by jorgenschaefer, who also is the lead on elpy!
#+BEGIN_SRC emacs-lisp :tangle init.el
(straight-use-package 'circe)
(use-package circe 
#+END_SRC

Currently not using ZNC, but this is probably still a good idea. 
#+BEGIN_SRC emacs-lisp :tangle init.el
  :config
  (setq circe-network-defaults nil)
#+END_SRC

It's very simple to configure circe to connect to ZNC (a personal irc server, essentially, that optionally saves the last 50 lines of chats so you have context upon logging in, amongst a whole slew of other features).
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq circe-network-options
        (let ((server-passwd
               (lambda (server-name)
                 (read-passwd (format "Password for server: %s? " server-name)))))
            `(("ZNC/freenode"
           :tls t
           :host "jarmac.org"
           :port 5013
           :user "alphor/freenode"
           :pass ,server-passwd)
           ("ZNC/mozilla"
            :tls t
            :host "jarmac.org"
            :port 5013
            :user "alphor/mozilla"
            :pass ,server-passwd)
           ("ZNC/snoonet"
            :tls t
            :host "jarmac.org"
            :port 5013
            :user "alphor/snoonet"
            :pass ,server-passwd)
           ("ZNC/gitter"
            :tls t
            :host "jarmac.org"
            :port 5013
            :user "alphor/gitter"
            :pass ,server-passwd)
           ("local/i2p"
            :tls t
            :host "localhost"
            :port 6668)
           ("freenode"
            :tls t
            :host "chat.freenode.net"
            :port 6697)
           ;; doesn't look that interesting anymore. Maybe later.
           ;; ("ZNC/rizon"
           ;;  :tls t
           ;;  :host "jarmac.org"
           ;;  :port 6697
           ;;  :user "alphor/rizon"
           ;;  :pass (lambda (server-name) (read-passwd "Password?: ")))
           )))
#+END_SRC

I have no idea why colored nicks are not enabled by default. Much prettier! (This is the default option I was complaining about earlier)
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; enable nicks
  (enable-circe-color-nicks)
#+END_SRC

Unfortunately, swiper calls font-lock-ensure-function which has the annoying habit of washing out all the color. I add a function to circe's mode hook that sets font-lock-ensure to the ignore function. 
#+BEGIN_SRC emacs-lisp :tangle init.el
  (add-hook 'circe-mode-hook 'my-font-lock-ensure-function-nilify)
#+END_SRC

Spammers have hit hard recently, cluttering my mode line. I like having the ability to see activity but at the same time I need my mode line. One thing I'd like to have is the ability to see only mentions. Everything else can wait. (This still allows queries to get through)
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq tracking-ignored-buffers '(((lambda (buf-name)
                                      (not (or (string-prefix-p "#emacs" buf-name)
                                               (not (string-prefix-p "#" buf-name)))))
                                    circe-highlight-nick-face)))
#+END_SRC

At the same time, I'd like tracking if I've talked. Someone's thought of that before and kindly put it in [[https://github.com/jorgenschaefer/circe/wiki/Configuration#auto-track-ignored-channels-on-talk][the docs]].

Unfortunately doesn't work quite well with such a lax regex, it'll require you to set up the channels you want to track before hand. Ah well, I'll leave it here for... some reason, and try fixing it later.
#+BEGIN_SRC emacs-lisp :tangle init.el
  ;; (defadvice circe-command-SAY (after jjf-circe-unignore-target)
  ;;   (let ((ignored (tracking-ignored-p (current-buffer) nil)))
  ;;     (when ignored
  ;;       (setq tracking-ignored-buffers
  ;;             (remove ignored tracking-ignored-buffers))
  ;;       (message "This buffer will now be tracked."))))
  ;; (ad-activate 'circe-command-SAY)
#+END_SRC

don't bombard me with leaves if the leaver hasn't spoke in a while.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq circe-reduce-lurker-spam t)
#+END_SRC

fun fact: the only other person that is also on both #freenode and ##wikimedia-kawaii is ChanServ
#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun my-circe-intersect-nicks (buf1 buf2)
    "Does what you think it does. It would make a little sense to remove your own nick from this list, but meh"
    (interactive "b\nb")
    (let ((names1 (with-current-buffer (set-buffer buf1)
                    (circe-channel-nicks)))
          (names2 (with-current-buffer (set-buffer buf2)
                    (circe-channel-nicks))))
      (message (prin1-to-string (-intersection names1 names2)))))
)
#+END_SRC

[[https://github.com/alphor/circe-actions][Circe-actions]] is a package that handles events coming in from IRC. 
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package
   '(circe-actions :type git :host github :repo "alphor/circe-actions"))

  (use-package circe-actions)
  (use-package circe-znc)
#+END_SRC

Useful for debugging interactively.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar circe-actions-inspect-arg-list '()
    "A list of variables that were passed to circe-actions-inspect-args.")
  (defun circe-actions-inspect-args (&rest args)
    "A utility function designed to show you what is passed to an
    arbitrary handler. Was very useful when inspecting, so I thought
    I'd leave it in here. Be warned with 30+ channels
    circe-actions-inspect-arg-list grows mighty fast, if you're adventerous
    and use circe-actions-t as a condition-function-p"
    (setq circe-actions-inspect-arg-list (cons args circe-actions-inspect-arg-list))
    (message
     (with-temp-buffer
       (cl-prettyprint args)
       (buffer-string)
       )))
#+END_SRC

Using ZNC, I'm on 80 channels. Everytime I connect to the server I get absolutely flooded, because it sends the name list for each channel. I should figure out how to ignore the first name list.

Don't mind this.
#+BEGIN_SRC 
(setq erc-server-auto-reconnect nil)
#+END_SRC

** nix-mode
I was so excited to find this. Indentation could use some more work, but much better than putting it in by hand.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package
    '(nix-mode :type git :host github :repo "alphor/nix-mode"
               :upstream (:host github :repo "NixOS/nix-mode")))
  (use-package nix-mode)

#+END_SRC

** regexp
re-builder is quick to use. Setting the syntax to 'string means I don't have to escape backslashes with backslashes.
#+BEGIN_SRC emacs-lisp :tangle init.el
(use-package re-builder
  :config
  (setq reb-re-syntax 'string))
#+END_SRC

** persistent bookmarks
registers are neat. let's try using them more often. If I bother creating a register, I want it to be persistent. Emacs calls persistent registers bookmarks, and to save them, you must either call `bookmark-save or configure it to save after x amount of bookmarks created
#+BEGIN_SRC emacs-lisp :tangle init.el
;; persistent bookmarks
(setq bookmark-save-flag 1) ; so save after every bookmark made.
#+END_SRC

** simple scrolling
Initially I just used the package (named simple-scrolling), but found that it caused weird graphical issues with browsing manual pages. This works just fine, although sometimes I miss the ability to have margins, but I also don't miss the jumpiness that sometimes occurred.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; simple scrolling
(progn
  (setq scroll-conservatively 10000)
  (setq auto-window-vscroll nil)
  )
#+END_SRC

** Directory clutter
From [[https://github.com/wasamasa/dotemacs/blob/master/init.org][wasamasa's config]] 

control, emacs.d/backup and emacs.d/autosave

#+BEGIN_SRC emacs-lisp :tangle init.el
;; Directory clutter
(setq backup-directory-alist '((".*" . "~/.emacs.d/backup")))
(setq version-control t)
(setq delete-old-versions t)

(setq auto-save-list-file-prefix "~/.emacs.d/autosave/")
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosave/" t)))
#+END_SRC

** Prefer "horizontal" splits when the frame has the space for it.
By horizontal I mean vim's (and the rest of the world's) notion of vertical. You split along the horizontal axis, I guess. Sure.

#+BEGIN_SRC emacs-lisp :tangle init.el
(setq split-height-threshold nil)
;; This works on a small 11 in screen, but I have a big screen with a docking station at home.
;; It would be great to preserve this behavior by relative size of screen, not absolute.
(setq split-width-threshold 140)
#+END_SRC

** project-specific
These were great so that I could use elpy to spin up a shell provided by nix.
Not really in use anymore.
#+BEGIN_SRC emacs-lisp :tangle init.el
   ;; here's an example, I no longer use it.
  (setq safe-local-variable-values
        '((python-shell-interpreter .  "/home/ajarara/proj/viz/repl.nix")
          (python-shell-interpreter .  "/home/ajarara/proj/webkov/shell.nix")))
#+END_SRC

** QOL fixes
I reject your reality and substitute my own.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; (setq custom-file "/dev/null")

(setq-default indent-tabs-mode nil)
#+END_SRC

** Theme
I like Monokai. In case I ever need to use a default theme, I'd use misterioso.
#+BEGIN_SRC emacs-lisp :tangle init.el

;; (load-theme 'misterioso t)
(straight-use-package 'monokai-theme)
(use-package monokai-theme
  :config
  (setq monokai-comments "chocolate")
  (load-theme `monokai t))

#+END_SRC

** projectile
projectile-compile-project shaves seconds off my builds. SECONDS!
#+BEGIN_SRC emacs-lisp :tangle init.el
  (straight-use-package 'projectile)
  (use-package projectile
    :demand t
      :bind*
      (("C-c c" . projectile-compile-project)
       ("C-c f" . projectile-find-file))
      :config
      (setq projectile-completion-system 'ivy))
#+END_SRC

** "my-" functions
Most of these are definitely not my code or my ideas. But they've definitely made a difference.

C-a C-k is again, the one emacs combo that I really like. But C-a pretends like whitespace isn't a thing. Found on the emacswiki:
#+BEGIN_SRC emacs-lisp :tangle init.el
;; something useful from the emacs wiki? No way.
(defun my-smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))
  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap move-beginning-of-line]
                'my-smarter-move-beginning-of-line)
#+END_SRC

This is primarily for killing help buffers without deleting the frame. I would replace this with shackle, but this works for now.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun my-kill-other-window ()
  (interactive)
  (if (= (count-windows) 2)
      (progn
        (other-window 1)
        (kill-buffer)
        (other-window 1))
    (error "This only works when there are two buffers!")))

#+END_SRC

in case something decides not to respect my "horizontal" preference.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; not mine, found off of emacs-wiki. quickly switches orientation of two buffers.
(defun my-toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

#+END_SRC

invaluable for quick edits. 
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun my-find-init-file ()
  "Displays the contents of ~/.emacs.d/myinit.org, if already shown, revert to previous buffer"
  (interactive)
  (let ((init-file-location "/home/ajarara/.emacs.d/README.org"))
    (if (string= init-file-location (buffer-file-name))
        (previous-buffer)
      (find-file init-file-location)))
  )
#+END_SRC

90% of what I play around with is in this folder, so I can easily select one of these folders to quickly start an editing session.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun my-find-projects ()
  "navigates to ~/Documents/projects"
  (interactive)
  (find-file "~/Documents/projects/"))
#+END_SRC

ditto to the above.
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun my-find-org-files ()
  "navigates to ~/Documents/org"
  (interactive)
  (find-file "~/Documents/org/"))
#+END_SRC

Sometimes font-lock-ensure-function is called (whenever you invoke swiper). Sometimes I want to disable it. There is likely a better way to do this, but this works for now. To use this, simply call it in any hook, and you get to keep your colors and fonts!
#+BEGIN_SRC emacs-lisp :tangle init.el
(defun my-font-lock-ensure-function-nilify ()
  (setq-local font-lock-ensure-function
        'ignore))
#+END_SRC

Useful quick links.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun my-github (query)
    (interactive "sSearch Github: ")
    (browse-url (format "https://github.com/search?q=%s" query)))

  ;; non obtrusive version of helm-google-suggest. Although helm-google-suggest is more fun
  (defun my-google (query)
    "It's mine! MIIIIIIINE!"
    (interactive "sSearch the googs: ")
    (browse-url (format "https://google.com/#q=%s" query)))
#+END_SRC


The help string for format-time-string is quite helpful.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (defun pelican-now (&optional arg)
    (interactive "P")
    (let ((date (format-time-string "%Y-%m-%d %H:%M:%S %z")))
      (if arg
          (insert date)
        (message date))))
#+END_SRC

** Binds (that don't belong to specific packages)

The emacs help system is absolutely fantastic. Unfortunately, in some cases, (looking at you, term-mode), it gets unbound. This keeps C-h bound to help.
#+BEGIN_SRC emacs-lisp :tangle init.el
(bind-key* "C-h" `help-command)
(bind-key* "C-h C-h" (lambda ()
    (interactive) (info "(emacs) Help Summary")))
#+END_SRC

Going back and forth with buffers with any sort of `jump-to` functionality is a common operation.
#+BEGIN_SRC emacs-lisp :tangle init.el
(bind-key* "M-[" `previous-buffer)
(bind-key* "M-]" `next-buffer)
#+END_SRC

With vertical splits, it's convenient to have a definition pop up in the other buffer. OTOH, if the definition is in the same buffer, maybe I'd like to keep the buffer. 
#+BEGIN_SRC emacs-lisp :tangle init.el
(bind-key* "M-." `xref-find-definitions-other-window)
#+END_SRC


In case I hit escape, but still want to quit. Binding some other functionality to this key is pretty risky anyway, so no loss there.
#+BEGIN_SRC emacs-lisp :tangle init.el
  (define-key key-translation-map (kbd "C-M-g") (kbd "C-g"))
#+END_SRC

dabbrev doesn't read me like hippie-expand does.
#+BEGIN_SRC emacs-lisp :tangle init.el
(global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

Y'know, there are astonishingly a lot of times where I'd like to quoted insert.
#+BEGIN_SRC emacs-lisp :tangle init.el
(bind-key* "M-q" `quoted-insert)
#+END_SRC

These are largely personal preference so not going to explain them.
#+BEGIN_SRC emacs-lisp :tangle init.el
;; shadows universal arg, I think? Damn, I need to read the manual.
(bind-key* "C-0" `text-scale-adjust)

;; shadows capitalize word (used to be my minor mode keymap, I moved all that to evil-leader, which I may eventually move to general)
(bind-key "M-c" `comment-dwim)

;; shadows indent-new-comment-line
(bind-key* "M-j" `end-of-buffer)

;; shadows move-to-window-line-top-bottom
(bind-key* "M-r" `delete-other-windows)

;; would like this instead to just kill the buffer, or like rotate. I think I need some buffer management tool
;; shadows kill-ring-save
(bind-key* "M-w" `delete-window)

;; I don't actually know what the name of the function is, but I know I don't need it. It's some typeface stuff.
;; also, the function name here is misleading, it evaluates the whole top-level expression, from anywhere in the expression, not just defuns
;; shadows Set face:

;; I'm gonna need shackle just for this async.
;; shadows universal argument, 7
(bind-key* "M-7" `async-shell-command)

;; shadows universal argument, 1
(bind-key* "M-1" `shell-command)

;; shadows prefix containing occur
(bind-key* "M-s" 'switch-to-buffer)

;; shadows tab-to-tab-stop
(bind-key* "M-i" `my-find-init-file)

;; instantly kills buffer (without deleting the window), unless unsaved content. this advices kill-buffer
;; shadows kill-sentence
(bind-key* "M-z" `kill-this-buffer)

;; U for undeaaaaaaaaaaaaaaaaad
;; shadows upcase-word
(bind-key* "M-u" `bury-buffer)

;; shadows nothing that I know of.
;; (bind-key* "M-p" `my-find-projects)

;; this leaves M-d free, for something. Although I use mode-d for colon/semicolon
;; shadows kill-sentence
(bind-key* "M-k" `kill-word)

;; shadows nothing
(bind-key* "M-\"" `insert-pair)

;; shadows nothing
(bind-key* "<f5>" `recompile)
#+END_SRC

** Hooks
org-mode hooks. Maybe these should go into package specific configuration. Meh.
#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook `org-mode-hook `org-indent-mode)
(add-hook `org-mode-hook `visual-line-mode)
#+END_SRC

apropos-mode hooks. Why does apropos not bind apropos-follow to anything easy?
#+BEGIN_SRC emacs-lisp :tangle init.el
(add-hook 'apropos-mode-hook (lambda () (local-set-key (kbd "C-c f") 'apropos-follow)))

#+END_SRC

ess-mode hooks
#+BEGIN_SRC emacs-lisp :tangle init.el
;; the <- shortcut is not helpful when you can't use hyphens in variable names

(add-hook 'ess-mode-hook (lambda () (local-set-key (kbd "_" 'self-insert-command)))) 

#+END_SRC

** Goodbye
Okay, we're done. Let's emit an OK.
#+BEGIN_SRC emacs-lisp :tangle init.el
(message "Emacs config successfully loaded!")
#+END_SRC

